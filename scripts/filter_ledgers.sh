#!/usr/bin/env bash
set -euo pipefail

# Post-process ledger metadata to:
# - classify files as single/main/included (main+included if both)
# - enforce uniqueness on basename+size
# - keep files that are >10KB, or main, or included
#
# Input must be generated by:
#   ./find_ledgers.sh --include-size --check-include --output <meta_file>
# Format (tab-separated):
#   raw_url  size  include_flag  include_targets_csv

usage() {
  cat <<'EOF'
Usage: filter_ledgers.sh [--list-main] <input_meta> [output_file]

Logic:
  - Load metadata from find_ledgers.sh (with include size + targets); if you ran
    get_includes.sh first, the include targets should already be present.
  - Mark types:
      main           -> file contains include directives
      included       -> file is referenced by another file's include
      main+included  -> both
      single         -> neither
  - Keep files if size > 10240 bytes OR type contains main OR included
  - Deduplicate on basename+size; merge type flags if duplicates occur
Flags:
  --list-main    Print kept main/main+included ledger URLs to stdout after the summary (output file still written)
Output columns (tab-separated):
  raw_url  size  type  include_targets_csv
EOF
}

list_main=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --list-main)
      list_main=true; shift;;
    -h|--help)
      usage; exit 0;;
    *)
      break;;
  esac
done

if [[ $# -lt 1 || $# -gt 2 ]]; then
  usage
  exit 1
fi

INPUT="$1"
OUTPUT="${2:-}"

[[ -f "$INPUT" ]] || { echo "Input not found: $INPUT" >&2; exit 1; }
[[ "$INPUT" == "-" ]] && { echo "Input file required (no stdin) for two-pass processing." >&2; exit 1; }

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }
}

tmpdir="$(mktemp -d)"
cleanup() { rm -rf "$tmpdir"; }
trap cleanup EXIT INT TERM

declare -A rec_url rec_size rec_incflag rec_targets rec_owner rec_repo rec_sha rec_path rec_dir
declare -A rec_main rec_included
declare -A path_to_id
declare -A key_to_id
records=0
input_rows=0
include_yes_rows=0
targets_declared=0          # raw targets (includes duplicates)
targets_unique=0            # unique targets after dedup
targets_resolved_existing=0
dedup_dropped=0
too_small=0
kept_rows=0
included_skipped=0
single_kept=0
main_kept=0
declare -a main_urls

add_or_merge_record() {
  local url="$1" size="$2" include_flag="$3" targets="$4" owner="$5" repo="$6" sha="$7" path="$8" dir="$9"
  local base key id
  base="${path##*/}"
  key="${base}|${size}"
  if [[ -n "${key_to_id[$key]:-}" ]]; then
    id="${key_to_id[$key]}"
    dedup_dropped=$((dedup_dropped + 1))
    # Even on dedupe, track this specific path so we can match include targets.
    path_to_id["$owner|$repo|$sha|$path"]="$id"
    # Merge include flag/targets.
    if [[ "$include_flag" == "yes" ]]; then
      rec_main["$id"]=1
    fi
    if [[ -n "$targets" ]]; then
      if [[ -n "${rec_targets[$id]:-}" ]]; then
        rec_targets["$id"]="${rec_targets[$id]},${targets}"
      else
        rec_targets["$id"]="$targets"
      fi
    fi
    rec_url["$id"]="$url"   # keep first or last; not critical for dedupe key
    rec_size["$id"]="$size"
    rec_owner["$id"]="$owner"
    rec_repo["$id"]="$repo"
    rec_sha["$id"]="$sha"
    rec_path["$id"]="$path"
    rec_dir["$id"]="$dir"
  else
    id="$records"
    records=$((records + 1))
    key_to_id[$key]="$id"
    path_to_id["$owner|$repo|$sha|$path"]="$id"
    rec_url["$id"]="$url"
    rec_size["$id"]="$size"
    rec_incflag["$id"]="$include_flag"
    rec_targets["$id"]="$targets"
    rec_owner["$id"]="$owner"
    rec_repo["$id"]="$repo"
    rec_sha["$id"]="$sha"
    rec_path["$id"]="$path"
    rec_dir["$id"]="$dir"
    [[ "$include_flag" == "yes" ]] && rec_main["$id"]=1
  fi
  return 0
}

resolve_path() {
  local base_dir="$1" target="$2"
  if [[ "$target" == /* ]]; then
    echo "${target#/}"
  elif [[ -z "$base_dir" || "$base_dir" == "." ]]; then
    echo "$target"
  else
    echo "$base_dir/$target"
  fi
}

url_encode_path() {
  # URL-encode a path segment for the GitHub contents API.
  python3 - <<'PY' "$1"
import sys, urllib.parse
print(urllib.parse.quote(sys.argv[1]))
PY
}

fetch_include_target() {
  local owner="$1" repo="$2" sha="$3" path="$4"
  local encoded_path
  encoded_path="$(url_encode_path "$path")"
  local api="https://api.github.com/repos/${owner}/${repo}/contents/${encoded_path}?ref=${sha}"
  local body="$tmpdir/body.$$" http_code size=""
  http_code="$(curl -sS -w '%{http_code}' -o "$body" -H "Accept: application/vnd.github+json" "${auth_header[@]}" "$api")" || {
    rm -f "$body"
    return 1
  }
  if [[ "$http_code" != "200" ]]; then
    rm -f "$body"
    return 1
  fi
  size="$(jq -r '.size // empty' "$body" 2>/dev/null || true)"
  rm -f "$body"
  [[ -z "$size" ]] && size="unknown"
  local raw_url="https://raw.githubusercontent.com/${owner}/${repo}/${sha}/${path}"
  add_or_merge_record "$raw_url" "$size" "no" "" "$owner" "$repo" "$sha" "$path" "${path%/*}"
  # Mark included later via included map.
  return 0
}

declare -A include_targets_needed

while IFS=$'\t' read -r url size include_flag include_targets; do
  [[ -z "$url" ]] && continue
  input_rows=$((input_rows + 1))
  # Parse raw.githubusercontent.com/{owner}/{repo}/{sha}/{path...}
  rel="${url#https://raw.githubusercontent.com/}"
  IFS='/' read -r owner repo sha path_rest <<<"$rel"
  path="${rel#${owner}/${repo}/${sha}/}"
  dir="${path%/*}"
  add_or_merge_record "$url" "$size" "$include_flag" "$include_targets" "$owner" "$repo" "$sha" "$path" "$dir"

  if [[ "$include_flag" == "yes" && -n "$include_targets" ]]; then
    include_yes_rows=$((include_yes_rows + 1))
    IFS=',' read -ra targets_arr <<<"$include_targets"
    for tgt in "${targets_arr[@]}"; do
      tgt="${tgt#"${tgt%%[![:space:]]*}"}"
      tgt="${tgt%"${tgt##*[![:space:]]}"}"
      [[ -z "$tgt" ]] && continue
      targets_declared=$((targets_declared + 1))
      resolved="$(resolve_path "$dir" "$tgt")"
      include_targets_needed["$owner|$repo|$sha|$resolved"]=1
      # If we already have the target, mark included flag below.
    done
  fi
done < "$INPUT"

targets_unique=${#include_targets_needed[@]}

# Mark existing records as included if referenced.
for key in "${!include_targets_needed[@]}"; do
  if [[ -n "${path_to_id[$key]:-}" ]]; then
    rec_included["${path_to_id[$key]}"]=1
    targets_resolved_existing=$((targets_resolved_existing + 1))
  fi
done

emit() {
  local url="$1" size="$2" type="$3" targets="$4"
  if [[ -n "$OUTPUT" ]]; then
    printf "%s\t%s\t%s\t%s\n" "$url" "$size" "$type" "$targets" >> "$OUTPUT"
  else
    printf "%s\t%s\t%s\t%s\n" "$url" "$size" "$type" "$targets"
  fi
}

[[ -n "$OUTPUT" ]] && : > "$OUTPUT"

min_size=10240
for id in "${!rec_url[@]}"; do
  url="${rec_url[$id]}"
  size="${rec_size[$id]}"
  targets="${rec_targets[$id]:-}"
  main_flag=0
  included_flag=0
  [[ -n "${rec_main[$id]:-}" ]] && main_flag=1
  [[ -n "${rec_included[$id]:-}" ]] && included_flag=1
  type="single"
  if (( main_flag==1 && included_flag==1 )); then
    type="main+included"
  elif (( main_flag==1 )); then
    type="main"
  elif (( included_flag==1 )); then
    type="included"
  fi

  size_num=0
  if [[ "$size" =~ ^[0-9]+$ ]]; then
    size_num="$size"
  fi

  # Skip pure include targets; handle elsewhere if needed.
  if (( included_flag==1 && main_flag==0 )); then
    included_skipped=$((included_skipped + 1))
    continue
  fi

  keep=0
  if (( size_num > min_size )); then
    keep=1
  fi
  if [[ "$type" == "main" || "$type" == "included" || "$type" == "main+included" ]]; then
    keep=1
  fi

  if [[ "$keep" -ne 1 ]]; then
    too_small=$((too_small + 1))
    continue
  fi
  kept_rows=$((kept_rows + 1))
  if [[ "$type" == "single" ]]; then
    single_kept=$((single_kept + 1))
  else
    main_kept=$((main_kept + 1))
    if [[ "$list_main" == true ]]; then
      main_urls+=("$url")
    fi
  fi
  emit "$url" "$size" "$type" "$targets"
done

if [[ -n "$OUTPUT" ]]; then
  echo "Filtered ledgers written to $OUTPUT"
fi

echo "=== filter_ledgers summary ===" >&2
printf "%-18s %7d\n" "Input rows:" "$input_rows" >&2
printf "%-18s %7d\n" "Deduped (dropped):" "$dedup_dropped" >&2
printf "%-18s %7d\n" "Included skipped:" "$included_skipped" >&2
printf "%-18s %7d\n" "Too small:" "$too_small" >&2
printf "%-18s %7d\n" "Total kept:" "$kept_rows" >&2
printf "%-18s %7d\n" "Total single:" "$single_kept" >&2
printf "%-18s %7d\n" "Total main:" "$main_kept" >&2

if [[ "$list_main" == true && ${#main_urls[@]} -gt 0 ]]; then
  echo "--- Main ledger URLs ---"
  for u in "${main_urls[@]}"; do
    echo "$u"
  done
fi
